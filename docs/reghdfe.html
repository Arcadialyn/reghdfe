
<html>
<head>
<title>help for reghdfe.ado</title>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" href="help.css">
</head>
<body>
<h2>help for reghdfe.ado</h2>
<pre>
<span class=result><u>Title</u></span>
<br><br>
    <span class=result>reghdfe</span> --   Linear and instrumental-variable/GMM regression absorbing
                   multiple levels of fixed effects
<br><br>
<a name="syntax"></a><span class=result><u>Syntax</u></span>
<br><br>
        <span class=result>reghdfe</span> <i>depvar</i> [<i>indepvars</i>] [<span class=result>(</span><i>endogvars</i> <span class=result>=</span> <i>iv_vars</i><span class=result>)</span>] [<i>if</i>] [<i>in</i>] <i>[</i><i>weight</i><i>]</i>
               <span class=result>,</span> <span class=result><u>a</u></span><span class=result>bsorb(</span><i>absvars</i><span class=result>)</span> [options]
<br><br>
<a name="opt_summary"></a>    <i>options</i>                 Description
    --------------------------------------------------------------------------
    Model [+]
    * <span class=result><u>a</u></span><span class=result>bsorb(</span><i>absvars</i><span class=result>)</span>       identifiers of the absorbed fixed effects; each
                              absvar represents one set of fixed effects
      <span class=result><u>a</u></span><span class=result>bsorb(</span><i>...</i><span class=result>,</span> <span class=result><u>save</u></span><span class=result>fe)</span>   save all fixed effect estimates (<i>__hdfe*</i> prefix);
                              useful for a subsequent predict.  However, see
                              also the <i>resid</i> option.
      <span class=result><u>res</u></span><span class=result>iduals(</span><i>newvar</i><span class=result>)</span>     save residuals; more direct and much faster than
                              saving the fixed effects and then running
                              predict
      <span class=result><u>su</u></span><span class=result>mmarize(</span><i>stats</i><span class=result>)</span>      equivalent to estat summarize after the
                              regression, but more flexible, compatible with
                              the <span class=result>fast</span> option, and saves results on
                              <i>e(summarize)</i>
      <span class=result><u>subopt</u></span><span class=result>ions(</span>...<span class=result>)</span>       additional options that will be passed to the
                              regression command (either regress, ivreg2, or 
                              ivregress)
        
    SE/Robust [+]
    + <span class=result>vce(</span>vcetype [<span class=result>,</span><i>opt</i>]<span class=result>)</span>   <i>vcetype</i> may be <span class=result><u>un</u></span><span class=result>adjusted</span> (default), <span class=result><u>r</u></span><span class=result>obust</span> or
                              <span class=result><u>cl</u></span><span class=result>uster</span> fvvarlist (allowing two- and multi-way
                              clustering)
                            suboptions <span class=result>bw(</span><i>#</i><span class=result>)</span>, <span class=result><u>ker</u></span><span class=result>nel(</span><i>str</i><span class=result>)</span>, <span class=result>dkraay(</span><i>#</i><span class=result>)</span> and
                              <span class=result>kiefer</span> allow for AC/HAC estimates; see the avar
                              package
<br><br>
    Instrumental-Variable/2SLS/GMM [+]
      <span class=result><u>est</u></span><span class=result>imator(</span><i>str</i><span class=result>)</span>        either <span class=result>2sls</span> (default), <span class=result><u>gmm</u></span><span class=result>2s</span> (two-stage GMM), <span class=result>liml</span>
                              (limited-information maximum likelihood) or <span class=result>cue</span>
                              (which gives approximate results, see discussion
                              below)
      <span class=result><u>stage</u></span><span class=result>s(</span><i>list</i><span class=result>)</span>          estimate additional regressions; choose any of
                              <span class=result>first</span> <span class=result>ols</span> <span class=result>reduced</span> <span class=result>acid</span> (or <span class=result>all</span>)
      <span class=result><u>ff</u></span><span class=result>irst</span>                compute first-stage diagnostic and identification
                              statistics
      <span class=result><u>iv</u></span><span class=result>suite(</span><i>subcmd</i><span class=result>)</span>       package used in the IV/GMM regressions; options
                              are <span class=result>ivreg2</span> (default; needs installing) and
                              <span class=result>ivregress</span>
<br><br>
    Diagnostic [+]
      <span class=result><u>v</u></span><span class=result>erbose(</span><i>#</i><span class=result>)</span>            amount of debugging information to show (0=None,
                              1=Some, 2=More, 3=Parsing/convergence details,
                              4=Every iteration)
      <span class=result><u>time</u></span><span class=result>it</span>                show elapsed times by stage of computation
<br><br>
    Optimization [+]
    + <span class=result><u>tol</u></span><span class=result>erance(</span><i>#</i><span class=result>)</span>          criterion for convergence (default=1e-8)
      <span class=result><u>maxit</u></span><span class=result>erations(</span><i>#</i><span class=result>)</span>      maximum number of iterations (default=10,000); if
                              set to missing (<span class=result>.</span>) it will run for as long as it
                              takes.
      <span class=result><u>pool</u></span><span class=result>size(</span><i>#</i><span class=result>)</span>           apply the within algorithm in groups of <i>#</i>
                              variables (default 10). a large poolsize is
                              usually faster but uses more memory
      <span class=result><u>accel</u></span><span class=result>eration(</span><i>str</i><span class=result>)</span>     acceleration method; options are
                              conjugate_gradient (cg), steep_descent (sd),
                              aitken (a), and none (no)
      <span class=result><u>transf</u></span><span class=result>orm(</span><i>str</i><span class=result>)</span>        transform operation that defines the type of
                              alternating projection; options are Kaczmarz
                              (kac), Cimmino (cim), Symmetric Kaczmarz (sym)
<br><br>
    Speedup Tricks [+]
      <span class=result>cache(save</span> [,opt]<span class=result>)</span>    absorb all variables without regressing
                              (destructive; combine it with preserve/restore)
                            suboption <span class=result>keep(</span><i>varlist</i><span class=result>)</span> adds additional
                              untransformed variables to the resulting dataset
      <span class=result>cache(use)</span>            run regressions on cached data; <i>vce()</i> must be the
                              same as with<span class=result> cache(save)</span>.
      <span class=result>cache(clear)</span>          delete Mata objects to clear up memory; no more
                              regressions can be run after this
      <span class=result>fast</span>                  will not create <i>e(sample)</i>; disabled when saving
                              fixed effects or mobility groups
<br><br>
    Degrees-of-Freedom Adjustments [+]
      <span class=result><u>dof</u></span><span class=result>adjustments(</span><i>list</i><span class=result>)</span>  allows selecting the desired adjustments for
                              degrees of freedom; rarely used
      <span class=result><u>groupv</u></span><span class=result>ar(</span><i>newvar</i><span class=result>)</span>      unique identifier for the first mobility group
<br><br>
    Reporting [+]
      <span class=result>version</span>               reports the version number and date of reghdfe,
                              and saves it in e(version). standalone option
      <span class=result><u>l</u></span><span class=result>evel(</span><i>#</i><span class=result>)</span>              set confidence level; default is <span class=result>level(95)</span>
      <i>display_options</i>       control column formats, row spacing, line width,
                              display of omitted variables and base and empty
                              cells, and factor-variable labeling
<br><br>
    Undocumented
      <span class=result><u>keepsin</u></span><span class=result>gletons</span>        do not drop singleton groups
      <span class=result>old</span>                   will call the latest 2.x version of reghdfe
                              instead (see the old help file)
    --------------------------------------------------------------------------
    * <span class=result>absorb(</span><i>absvars</i><span class=result>)</span> is required.
    + indicates a recommended or important option.
    <i>indepvars</i>, <i>endogvars</i> and <i>iv_vars</i> may contain factor variables; see 
      fvvarlist.
    all the regression variables may contain time-series operators; see 
      tsvarlist.
    <span class=result>fweight</span>s, <span class=result>aweight</span>s and <span class=result>pweight</span>s are allowed; see weight.
<br><br>
<br><br>
<a name="absvar"></a><span class=result><u>Absvar Syntax</u></span>
<br><br>
    <i>absvar</i>                  Description
    --------------------------------------------------------------------------
    <span class=result>i.</span><i>varname</i>               categorical variable to be absorbed (the <span class=result>i.</span> prefix
                              is tacit)
    <span class=result>i.</span><i>var1</i><span class=result>#i.</span><i>var2</i>           absorb the interactions of multiple categorical
                              variables
    <span class=result>i.</span><i>var1</i><span class=result>#c.</span><i>var2</i>           absorb heterogeneous slopes, where <i>var2</i> has a
                              different slope coef. depending on the category
                              of <i>var1</i>
    <i>var1</i><span class=result>##c.</span><i>var2</i>            equivalent to "<span class=result>i.</span><i>var1</i> <span class=result>i.</span><i>var1</i><span class=result>#c.</span><i>var2</i>", but <i>much</i>
                              faster
    <i>var1</i><span class=result>##c.(</span><i>var2 var3</i><span class=result>)</span>     multiple heterogeneous slopes are allowed
                              together. Alternative syntax: <i>var1</i><span class=result>##(c.</span><i>var2</i>
                              <span class=result>c.</span><i>var3</i><span class=result>)</span>
    <i>v1</i><span class=result>#</span><i>v2</i><span class=result>#</span><i>v3</i><span class=result>##c.(</span><i>v4 v5</i><span class=result>)</span>     factor operators can be combined
    --------------------------------------------------------------------------
    To save the estimates specific absvars, write <i>newvar</i><span class=result>=</span><i>absvar</i>.
    Please be aware that in most cases these estimates are neither consistent
      nor econometrically identified.
    Using categorical interactions (e.g. <i>x</i><span class=result>#</span><i>z</i>) is faster than running <i>egen</i>
      <i>group(...)</i> beforehand.
    Singleton obs. are dropped iteratively until no more singletons are found
      (see ancilliary article for details).
    Slope-only absvars ("state#c.time") have poor numerical stability and slow
      convergence.  If you need those, either i) increase tolerance or ii) use
      slope-and-intercept absvars ("state##c.time"), even if the intercept is
      redundant.  For instance if absvar is "i.zipcode i.state##c.time" then
      i.state is redundant given i.zipcode, but convergence will still be <i>much</i>
      faster.
<br><br>
<a name="description"></a><span class=result><u>Description</u></span>
<br><br>
    <span class=result>reghdfe</span> is a generalization of areg (and xtreg,fe, xtivreg,fe) for
    multiple levels of fixed effects (including heterogeneous slopes),
    alternative estimators (2sls, gmm2s, liml), and additional robust standard
    errors (multi-way clustering, HAC standard errors, etc).
<br><br>
    Additional features include:
     a) A novel and robust algorithm to efficiently absorb the fixed effects
        (extending the work of Guimaraes and Portugal, 2010).
     b) Coded in Mata, which in most scenarios makes it even faster than <i>areg</i>
        and <i>xtreg</i> for a single fixed effect (see benchmarks on the Github
        page).
     c) Can save the point estimates of the fixed effects (<i>caveat emptor</i>: the
        fixed effects may not be identified, see the references).
     d) Calculates the degrees-of-freedom lost due to the fixed effects (note:
        beyond two levels of fixed effects, this is still an open problem, but
        we provide a conservative approximation).
     e) Iteratively removes singleton groups by default, to avoid biasing the
        standard errors (see ancillary document).
<br><br>
<a name="options"></a><span class=result><u>Options</u></span>
<br><br>
<a name="opt_model"></a>        +-----------------------+
    ----+ Model and Miscellanea +---------------------------------------------
<br><br>
    <span class=result><u>a</u></span><span class=result>bsorb(</span><i>absvars</i><span class=result>)</span> list of categorical variables (or interactions)
        representing the fixed effects to be absorbed.  this is equivalent to
        including an indicator/dummy variable for each category of each
        <i>absvar</i>. <span class=result>absorb()</span> is required.
<br><br>
        To save a fixed effect, prefix the absvar with "<i>newvar</i><span class=result>=</span>".  For
        instance, the option <span class=result>absorb(firm_id worker_id year_coefs=year_id)</span> will
        include firm, worker and year fixed effects, but will only save the
        estimates for the year fixed effects (in the new variable <i>year_coefs</i>).
<br><br>
        If you want to predict afterwards but don't care about setting the
        names of each fixed effect, use the <span class=result><u>save</u></span><span class=result>fe</span> suboption.  This will
        delete all variables named <i>__hdfe*__</i> and create new ones as required.
        Example: <i>reghdfe price weight, absorb(turn trunk, savefe)</i>
<br><br>
    <span class=result><u>res</u></span><span class=result>iduals(</span><i>newvar</i><span class=result>)</span> will save the regression residuals in a new variable.
<br><br>
        This is a superior alternative than running <span class=result>predict, resid</span> afterwards
        as it's faster and doesn't require saving the fixed effects.
<br><br>
    <span class=result><u>su</u></span><span class=result>mmarize(</span><i>stats</i><span class=result>)</span> will report and save a table of summary of statistics of
        the regression variables (including the instruments, if applicable),
        using the same sample as the regression.
<br><br>
        <span class=result><u>su</u></span><span class=result>mmarize</span> (without parenthesis) saves the default set of statistics:
        <i>mean min max</i>.
<br><br>
        The complete list of accepted statistics is available in the tabstat
        help. The most useful are <i>count range sd median p##</i>.
<br><br>
        The summary table is saved in <i>e(summarize)</i>
<br><br>
        To save the summary table silently (without showing it after the
        regression table), use the <span class=result><u>qui</u></span><span class=result>etly</span> suboption. You can use it by itself
        (<span class=result>summarize(,quietly)</span>) or with custom statistics (<span class=result>summarize(mean,</span>
        <span class=result>quietly)</span>).
<br><br>
    <span class=result><u>subopt</u></span><span class=result>ions(</span>...<span class=result>)</span> options that will be passed directly to the regression
        command (either regress, ivreg2, or ivregress)
<br><br>
<a name="opt_vce"></a>        +-----------+
    ----+ SE/Robust +---------------------------------------------------------
<br><br>
    <span class=result>vce(</span><i>vcetype, subopt</i><span class=result>)</span> specifies the type of standard error reported.  Note
        that all the advanced estimators rely on asymptotic theory, and will
        likely have poor performance with small samples (but again if you are
        using reghdfe, that is probably not your case)
<br><br>
        <span class=result><u>un</u></span><span class=result>adjusted</span>/<span class=result>ols</span> estimates conventional standard errors, valid even in
        small samples under the assumptions of homoscedasticity and no
        correlation between observations
<br><br>
        <span class=result><u>r</u></span><span class=result>obust</span> estimates heteroscedasticity-consistent standard errors
        (Huber/White/sandwich estimators), but still assuming independence
        between observations
<br><br>
        Warning: in a FE panel regression, using <span class=result><u>r</u></span><span class=result>obust</span> will lead to
        inconsistent standard errors if for every fixed effect, the <i>other</i>
        dimension is fixed.  For instance, in an standard panel with
        individual and time fixed effects, we require both the number of
        individuals and time periods to grow asymptotically.  If that is not
        the case, an alternative may be to use clustered errors, which as
        discussed below will still have their own asymptotic requirements.
        For a discussion, see Stock and Watson, "Heteroskedasticity-robust
        standard errors for fixed-effects panel-data regression," Econometrica
        76 (2008): 155-174
<br><br>
        <span class=result><u>cl</u></span><span class=result>uster</span> <i>clustervars</i> estimates consistent standard errors even when the
        observations are correlated within groups.
<br><br>
        Multi-way-clustering is allowed. Thus, you can indicate as many
        <i>clustervar</i>s as desired (e.g. allowing for intragroup correlation
        across individuals, time, country, etc).
<br><br>
        Each <i>clustervar</i> permits interactions of the type <i>var1</i><i>#</i><i>var2</i> (this is
        faster than using <span class=result>egen group()</span> for a one-off regression).
<br><br>
        Warning: The number of clusters, for all of the cluster variables,
        must go off to infinity.  A frequent rule of thumb is that each
        cluster variable must have at least 50 different categories (the
        number of categories for each clustervar appears on the header of the
        regression table).
<br><br>
    The following suboptions require either the ivreg2 or the avar package
    from SSC.  For a careful explanation, see the ivreg2 help file, from which
    the comments below borrow.
<br><br>
        <span class=result><u>u</u></span><span class=result>nadjusted, bw(</span><i>#</i><span class=result>)</span> (or just <span class=result>, bw(</span><i>#</i><span class=result>)</span>) estimates
        autocorrelation-consistent standard errors (Newey-West).
<br><br>
        <span class=result><u>r</u></span><span class=result>obust, bw(</span><i>#</i><span class=result>)</span> estimates autocorrelation-and-heteroscedasticity
        consistent standard errors (HAC).
<br><br>
        <span class=result><u>cl</u></span><span class=result>uster</span> <i>clustervars</i><span class=result>, bw(</span><i>#</i><span class=result>)</span> estimates standard errors consistent to
        common autocorrelated disturbances (Driscoll-Kraay). At most two
        cluster variables can be used in this case.
<br><br>
        <span class=result>, kiefer</span> estimates standard errors consistent under arbitrary
        intra-group autocorrelation (but not heteroskedasticity) (Kiefer).
<br><br>
        <span class=result>kernel(</span><i>str</i><span class=result>)</span> is allowed in all the cases that allow <span class=result>bw(</span><i>#</i><span class=result>)</span> The default
        kernel is <i>bar</i> (Bartlett). Valid kernels are Bartlett (bar); Truncated
        (tru); Parzen (par); Tukey-Hanning (thann); Tukey-Hamming (thamm);
        Daniell (dan); Tent (ten); and Quadratic-Spectral (qua or qs).
<br><br>
    Advanced suboptions:
<br><br>
        <span class=result>, suite(</span><i>default</i>|<i>mwc</i>|<i>avar</i><span class=result>)</span> overrides the package chosen by reghdfe to
        estimate the VCE.  <i>default</i> uses the default Stata computation (allows
        unadjusted, robust, and at most one cluster variable).  <i>mwc</i> allows
        multi-way-clustering (any number of cluster variables), but without
        the <i>bw</i> and <i>kernel</i> suboptions.  <i>avar</i> uses the avar package from SSC. Is
        the same package used by ivreg2, and allows the <i>bw</i>, <i>kernel</i>, <i>dkraay</i> and
        <i>kiefer</i> suboptions.  This is useful almost exclusively for debugging.
<br><br>
        <span class=result>, </span><span class=result><u>twice</u></span><span class=result>robust</span> will compute robust standard errors not only on the
        first but on the second step of the gmm2s estimation. Requires
        <span class=result>ivsuite(</span><i>ivregress</i><span class=result>)</span>, but will not give the exact same results as
        ivregress.
<br><br>
        <i>Explanation:</i> When running instrumental-variable regressions with the
        <span class=result>ivregress</span> package, robust standard errors, and a gmm2s estimator,
        reghdfe will translate <span class=result>vce(</span><i>robust</i><span class=result>)</span> into <span class=result>wmatrix(</span><i>robust</i><span class=result>)</span>
        <span class=result>vce(</span><i>unadjusted</i><span class=result>)</span>.  This maintains compatibility with <span class=result>ivreg2</span> and other
        packages, but may unadvisable as described in ivregress (technical
        note). Specifying this option will instead use <span class=result>wmatrix(</span><i>robust</i><span class=result>)</span>
        <span class=result>vce(</span><i>robust</i><span class=result>)</span>.
<br><br>
        However, computing the second-step vce matrix requires computing
        updated estimates (including updated fixed effects).  Since reghdfe
        currently does not allow this, the resulting standard errors <span class=result>will not</span>
        <span class=result>be exactly the same as with ivregress</span>.  This issue is similar to
        applying the CUE estimator, described further below.
<br><br>
        Note: The above comments are also appliable to clustered standard
        error.
<br><br>
<a name="opt_iv"></a>        +-------------+
    ----+ IV/2SLS/GMM +-------------------------------------------------------
<br><br>
    <span class=result><u>est</u></span><span class=result>imator(2sls</span>|<span class=result><u>gmm</u></span><span class=result>2s</span>|<span class=result>liml</span>|<span class=result>cue)</span> estimator used in the instrumental-variable
        estimation
<br><br>
        <span class=result>2sls</span> (two-stage least squares, default), <span class=result><u>gmm</u></span><span class=result>2s</span> (two-stage efficient
        GMM), <span class=result>liml</span> (limited-information maximum likelihood), and <span class=result>cue</span>
        ("continuously-updated" GMM) are allowed.
<br><br>
        Warning: <span class=result>cue</span> will not give the same results as ivreg2. See the
        discussion in  Baum, Christopher F., Mark E. Schaffer, and Steven
        Stillman. "Enhanced routines for instrumental variables/GMM estimation
        and testing." Stata Journal 7.4 (2007): 465-506 (page 484).  Note that
        even if this is not exactly <span class=result>cue</span>, it may still be a desirable/useful
        alternative to standard cue, as explained in the article.
<br><br>
    <span class=result><u>stage</u></span><span class=result>s(</span><i>list</i><span class=result>)</span> adds and saves up to four auxiliary regressions useful when
        running instrumental-variable regressions:
<br><br>
        <span class=result>first</span> all first-stage regressions
        <span class=result>ols</span> ols regression (between dependent variable and endogenous
            variables; useful as a benchmark)
        <span class=result>reduced</span> reduced-form regression (ols regression with included and
            excluded instruments as regressors)
        <span class=result>acid</span> an "acid" regression that includes both instruments and
            endogenous variables as regressors; in this setup, excluded
            instruments should not be significant.
<br><br>
        You can pass suboptions not just to the iv command but to all stage
        regressions with a comma after the list of stages. Example:
        <i>reghdfe price (weight=length), absorb(turn) subopt(nocollin)</i>
        <i>stages(first, eform(exp(beta)) )</i>
<br><br>
        By default all stages are saved (see estimates dir).  The suboption
        <span class=result>,nosave</span> will prevent that.  However, future <span class=result>replay</span>s will only replay
        the iv regression.
<br><br>
    <span class=result>ffirst</span> compute and report first stage statistics (details); requires the
        ivreg2 package.
<br><br>
        These statistics will be saved on the <i>e(first)</i> matrix.  If the
        first-stage estimates are also saved (with the <span class=result>stages()</span> option), the
        respective statistics will be copied to <span class=result>e(first_*)</span> locals.
<br><br>
    <span class=result><u>iv</u></span><span class=result>suite(</span><i>subcmd</i><span class=result>)</span> allows the IV/2SLS regression to be run either using
        <span class=result>ivregress</span> or <span class=result>ivreg2</span>.
<br><br>
        <span class=result>ivreg2</span> is the default, but needs to be installed for that option to
        work.
<br><br>
<a name="opt_diagnostic"></a>        +------------+
    ----+ Diagnostic +--------------------------------------------------------
<br><br>
    <span class=result><u>v</u></span><span class=result>erbose(</span><i>#</i><span class=result>)</span> orders the command to print debugging information.
<br><br>
        Possible values are 0 (none), 1 (some information), 2 (even more), 3
        (adds dots for each iteration, and reportes parsing details), 4 (adds
        details for every iteration step)
<br><br>
        For debugging, the most useful value is 3. For simple status reports,
        set verbose to 1.
<br><br>
    <span class=result><u>time</u></span><span class=result>it</span> shows the elapsed time at different steps of the estimation. Most
        time is usually spent on three steps: map_precompute(), map_solve()
        and the regression step.
<br><br>
<a name="opt_dof"></a>        +--------------------------------+
    ----+ Degrees-of-Freedom Adjustments +------------------------------------
<br><br>
    <span class=result><u>dof</u></span><span class=result>adjustments(</span><i>doflist</i><span class=result>)</span> selects how the degrees-of-freedom, as well as
        e(df_a), are adjusted due to the absorbed fixed effects.
<br><br>
        Without any adjustment, we would assume that the degrees-of-freedom
        used by the fixed effects is equal to the count of all the fixed
        effects (e.g. number of individuals + number of years in a typical
        panel).  However, in complex setups (e.g. fixed effects by individual,
        firm, job position, and year), there may be a huge number of fixed
        effects collinear with each other, so we want to adjust for that.
<br><br>
        Note: changing the default option is rarely needed, except in
        benchmarks, and to obtain a marginal speed-up by excluding the
        <span class=result><u>pair</u></span><span class=result>wise</span> option.
<br><br>
        <span class=result>all</span> is the default and almost always the best alternative. It is
        equivalent to <span class=result>dof(</span><i>pairwise clusters continuous</i><span class=result>)</span>
<br><br>
        <span class=result>none</span> assumes no collinearity across the fixed effects (i.e. no
        redundant fixed effects). This is overtly conservative, although it is
        the faster method by virtue of not doing anything.
<br><br>
        <span class=result><u>first</u></span><span class=result>pair</span> will exactly identify the number of collinear fixed effects
        across the first two sets of fixed effects (i.e. the first absvar and
        the second absvar).  The algorithm used for this is described in Abowd
        et al (1999), and relies on results from graph theory (finding the
        number of connected sub-graphs in a bipartite graph).  It will not do
        anything for the third and subsequent sets of fixed effects.
<br><br>
        For more than two sets of fixed effects, there are no known results
        that provide exact degrees-of-freedom as in the case above.  One
        solution is to ignore subsequent fixed effects (and thus oversestimate
        e(df_a) and understimate the degrees-of-freedom).  Another solution,
        described below, applies the algorithm between pairs of fixed effects
        to obtain a better (but not exact) estimate:
<br><br>
        <span class=result><u>pair</u></span><span class=result>wise</span> applies the aforementioned connected-subgraphs algorithm
        between pairs of fixed effects.  For instance, if there are four sets
        of FEs, the first dimension will usually have no redundant
        coefficients (i.e. e(M1)==1), since we are running the model without a
        constant.  For the second FE, the number of connected subgraphs with
        respect to the first FE will provide an exact estimate of the
        degrees-of-freedom lost, e(M2).
<br><br>
        For the third FE, we do not know exactly.  However, we can compute the
        number of connected subgraphs between the first and third <i>G(1,3)</i>, and
        second and third <i>G(2,3)</i> fixed effects, and choose the higher of those
        as the closest estimate for e(M3).  For the fourth FE, we compute
        <i>G(1,4)</i>, <i>G(2,4)</i> and <i>G(3,4)</i> and again choose the highest for e(M4).
<br><br>
        Finally, we compute e(df_a) = e(K1) - e(M1) + e(K2) - e(M2) + e(K3) -
        e(M3) + e(K4) - e(M4); where e(K#) is the number of levels or
        dimensions for the #-th fixed effect (e.g. number of individuals or
        years).  Note that e(M3) and e(M4) are only conservative estimates and
        thus we will usually be overestimating the standard errors. However,
        given the sizes of the datasets typically used with reghdfe, the
        difference should be small.
<br><br>
        Since the gain from <span class=result><u>pair</u></span><span class=result>wise</span> is usually <i>minuscule</i> for large datasets,
        and the computation is expensive, it may be a good practice to exclude
        this option for speedups.
<br><br>
        <span class=result><u>cl</u></span><span class=result>usters</span> will check if a fixed effect is nested within a <i>clustervar</i>.
        In that case, it will set e(K#)==e(M#) and no degrees-of-freedom will
        be lost due to this fixed effect.  The rationale is that we are
        already assuming that the number of effective observations is the
        number of cluster levels.  This is the same adjustment that <span class=result>xtreg, fe</span>
        does, but <span class=result>areg</span> does not use it.
<br><br>
        <span class=result><u>cont</u></span><span class=result>inuous</span> Fixed effects with continuous interactions (i.e. individual
        slopes, instead of individual intercepts) are dealt with differently.
        In an i.categorical#c.continuous interaction, we will do one check: we
        count the number of categories where c.continuous is always zero.  In
        an i.categorical##c.continuous interaction, we do the above check but
        replace zero for any particular constant.  In the case where
        continuous is constant for a level of categorical, we know it is
        collinear with the intercept, so we adjust for it.
<br><br>
        Additional methods, such as <span class=result>bootstrap</span> are also possible but not yet
        implemented.  Some preliminary simulations done by the author showed a
        very poor convergence of this method.
<br><br>
    <span class=result><u>groupv</u></span><span class=result>ar(</span><i>newvar</i><span class=result>)</span> name of the new variable that will contain the first
        mobility group.  Requires <span class=result><u>pair</u></span><span class=result>wise</span>, <span class=result><u>first</u></span><span class=result>pair</span>, or the default <span class=result>all</span>.
<br><br>
<a name="opt_speedup"></a>        +------------------------+
    ----+ Speeding Up Estimation +--------------------------------------------
<br><br>
    <span class=result>reghdfe</span> <i>varlist</i> [<i>if</i>] [<i>in</i>]<span class=result>,</span> <span class=result><u>a</u></span><span class=result>bsorb(</span><i>absvars</i><span class=result>)</span> <span class=result>save(cache)</span> [<i>options</i>]
<br><br>
        This will transform <i>varlist</i>, absorbing the fixed effects indicated by
        <i>absvars</i>.  It is useful when running a series of alternative
        specifications with common variables, as the variables will only be
        transformed once instead of every time a regression is run.
<br><br>
        It replaces the current dataset, so it is a good idea to precede it
        with a preserve command
<br><br>
        To keep additional (untransformed) variables in the new dataset, use
        the <span class=result>keep(</span><i>varlist</i><span class=result>)</span> suboption.
<br><br>
    <span class=result>cache(use)</span> is used when running reghdfe after a <i>save(cache)</i> operation.
        Both the <i>absorb()</i> and <i>vce()</i> options must be the same as when the cache
        was created (the latter because the degrees of freedom were computed
        at that point).
<br><br>
    <span class=result>cache(clear)</span> will delete the Mata objects created by <i>reghdfe</i> and kept in
        memory after the <i>save(cache)</i> operation. These objects may consume a
        lot of memory, so it is a good idea to clean up the cache.
        Additionally, if you previously specified <i>preserve</i>, it may be a good
        time to <i>restore</i>.
<br><br>
        Example:
        <span class=input>. sysuse auto</span>
        <span class=input>. preserve</span>
        <span class=result>.</span>
        <span class=input>. * Save the cache</span>
        <span class=input>. reghdfe price weight length, a(turn rep) vce(turn) cache(save,</span>
            <span class=result>keep(foreign))</span>
        <span class=result>.</span>
        <span class=input>. * Run regressions</span>
        <span class=input>. reghdfe price weight, a(turn rep) cache(use)</span>
        <span class=input>. reghdfe price length, a(turn rep) cache(use)</span>
        <span class=result>.</span>
        <span class=input>. * Clean up</span>
        <span class=input>. reghdfe, cache(clear)</span>
        <span class=input>. restore</span>
<br><br>
    <span class=result>fast</span> avoids saving <i>e(sample)</i> into the regression.  Since saving the
        variable only involves copying a Mata vector, the speedup is currently
        quite small.  Future versions of reghdfe may change this as features
        are added.
<br><br>
        Note that <span class=result>fast</span> will be disabled when adding variables to the dataset
        (i.e. when saving residuals, fixed effects, or mobility groups), and
        is incompatible with most postestimation commands.
<br><br>
        If you wish to use <span class=result>fast</span> while reporting <span class=result>estat summarize</span>, see the
        <span class=result>summarize</span> option.
<br><br>
<a name="opt_optimization"></a>        +--------------+
    ----+ Optimization +------------------------------------------------------
<br><br>
    <span class=result><u>tol</u></span><span class=result>erance(</span><i>#</i><span class=result>)</span> specifies the tolerance criterion for convergence; default is
        <span class=result>tolerance(1e-8)</span>
<br><br>
        Note that for tolerances beyond 1e-14, the limits of the <i>double</i>
        precision are reached and the results will most likely not converge.
<br><br>
        At the other end, is not tight enough, the regression may not identify
        perfectly collinear regressors. However, those cases can be easily
        spotted due to their extremely high standard errors.
<br><br>
        Warning: when absorbing heterogeneous slopes without the accompanying
        heterogeneous intercepts, convergence is quite poor and a tight
        tolerance is strongly suggested (i.e. higher than the default). In
        other words, an absvar of <i>var1##c.var2</i> converges easily, but an absvar
        of <i>var1#c.var2</i> will converge slowly and may require a tighter
        tolerance.
<br><br>
    <span class=result><u>maxit</u></span><span class=result>erations(</span><i>#</i><span class=result>)</span> specifies the maximum number of iterations; the default
        is <span class=result>maxiterations(10000)</span>; set it to missing (<span class=result>.</span>) to run forever until
        convergence.
<br><br>
    <span class=result><u>pool</u></span><span class=result>size(</span><i>#</i><span class=result>)</span> Number of variables that are <i>pooled together</i> into a matrix
        that will then be transformed.  The default is to pool variables in
        groups of 5. Larger groups are faster with more than one processor,
        but may cause out-of-memory errors. In that case, set poolsize to 1.
<br><br>
    <i>Advanced options:</i>
<br><br>
    <span class=result>acceleration(</span><i>str</i><span class=result>)</span> allows for different acceleration techniques, from the
        simplest case of no acceleration (<span class=result><u>no</u></span><span class=result>ne</span>), to steep descent
        (<span class=result><u>st</u></span><span class=result>eep_descent</span> or <span class=result>sd</span>), Aitken (<span class=result><u>a</u></span><span class=result>itken</span>), and finally Conjugate Gradient
        (<span class=result><u>co</u></span><span class=result>njugate_gradient</span> or <span class=result>cg</span>).
<br><br>
        Note: Each acceleration is just a plug-in Mata function, so a larger
        number of acceleration techniques are available, albeit undocumented
        (and slower).
<br><br>
    <span class=result><u>transf</u></span><span class=result>orm(</span><i>str</i><span class=result>)</span> allows for different "alternating projection" transforms.
        The classical transform is Kaczmarz (<span class=result><u>kac</u></span><span class=result>zmarz</span>), and more stable
        alternatives are Cimmino (<span class=result><u>cim</u></span><span class=result>mino</span>) and Symmetric Kaczmarz
        (<span class=result><u>sym</u></span><span class=result>metric_kaczmarz</span>)
<br><br>
        Note: Each transform is just a plug-in Mata function, so a larger
        number of acceleration techniques are available, albeit undocumented
        (and slower).
<br><br>
        Note: The default acceleration is Conjugate Gradient and the default
        transform is Symmetric Kaczmarz. Be wary that different accelerations
        often work better with certain transforms. For instance, do not use
        conjugate gradient with plain Kaczmarz, as it will not converge.
<br><br>
    <span class=result>precondition</span> <i>(currently disabled)</i>
<br><br>
<a name="opt_reporting"></a>        +-----------+
    ----+ Reporting +---------------------------------------------------------
<br><br>
    <span class=result><u>l</u></span><span class=result>evel(</span><i>#</i><span class=result>)</span> sets confidence level; default is <span class=result>level(95)</span>
<br><br>
<a name="display_options"></a>    <i>display_options</i>:  <span class=result><u>noomit</u></span><span class=result>ted</span>, <span class=result>vsquish</span>, <span class=result><u>noempty</u></span><span class=result>cells</span>, <span class=result><u>base</u></span><span class=result>levels</span>,
        <span class=result><u>allbase</u></span><span class=result>levels</span>, <span class=result>nofvlabel</span>, <span class=result>fvwrap(</span><i>#</i><span class=result>)</span>, <span class=result>fvwrapon(</span><i>style</i><span class=result>)</span>, <span class=result>cformat(</span><i>%fmt</i><span class=result>)</span>,
        <span class=result>pformat(%</span><i>fmt</i><span class=result>)</span>, <span class=result>sformat(%</span><i>fmt</i><span class=result>)</span>, and <span class=result>nolstretch</span>; see <span class=result>[R] estimation</span>
        <span class=result>options</span>.
<br><br>
<br><br>
<a name="postestimation"></a><span class=result><u>Postestimation Syntax</u></span>
<br><br>
Only <span class=result>estat summarize</span>, <span class=result>predict</span> and <span class=result>test</span> are currently supported and tested.
<br><br>
        <span class=result>estat summarize</span>
                      Summarizes <i>depvar</i> and the variables described in <i>_b</i> (i.e. 
&gt; not the excluded instruments)
<br><br>
        <span class=result>predict</span> <i>newvar</i> [<i>if</i>] [<i>in</i>] [<span class=result>,</span> <i>statistic</i>]
                      Requires all set of fixed effects to be previously saved b
&gt; y <span class=result>reghdfe</span> (except for option <span class=result>xb</span>)
                      Equation: y = xb + d_absorbvars + e
<br><br>
    <i>statistic</i>             Description
    --------------------------------------------------------------------------
    Main
    <span class=result>xb</span>                    xb fitted values; the default
    <span class=result>xbd</span>                   xb + d_absorbvars
    <span class=result>d</span>                     d_absorbvars
    <span class=result><u>r</u></span><span class=result>esiduals</span>             residual
    <span class=result><u>sc</u></span><span class=result>ore</span>                 score; equivalent to <span class=result>residuals</span>
    --------------------------------------------------------------------------
<br><br>
        <span class=result>test</span>
                      Performs significance test on the parameters, see the stat
&gt; a help
<br><br>
        <span class=result>suest</span>
<br><br>
    If you want to perform tests that are usually run with <span class=result>suest</span>, such as
    non-nested models, tests using alternative specifications of the
    variables, or tests on different groups, you can replicate it manually, as
    described here.
<br><br>
    Note: do not use <span class=result>suest</span>. It will run, but the results will be incorrect.
<br><br>
<a name="remarks"></a><br><br>
<span class=result><u>Possible Pitfalls and Common Mistakes</u></span>
<br><br>
     1. (note: as of version 2.1, the constant is no longer reported) Ignore
        the constant; it doesn't tell you much. If you want to use descriptive
        stats, that's what the <span class=result><u>sum</u></span><span class=result>marize()</span> and <span class=result>estat summ</span> commands are for.
        Even better, use <span class=result>noconstant</span> to drop it (although it's not really
        dropped as it never existed on the first place!)
     2. Think twice before saving the fixed effects. They are probably
        inconsistent / not identified and you will likely be using them wrong.
     3. (note: as of version 3.0 singletons are dropped by default) It's good
        practice to drop singletons. <span class=result><u>dropsi</u></span><span class=result>ngleton</span> is your friend.
     4. If you use <span class=result>vce(</span><i>robust</i><span class=result>)</span>, be sure that your <i>other</i> dimension is not
        "fixed" but grows with N, or your SEs will be wrong.
     5. If you use <span class=result>vce(</span><i>cluster </i>...<span class=result>)</span>, check that your number of clusters is
        high enough (50+ is a rule of thumb). If not, you are making the SEs
        even worse!
     6. The panel variables (absvars) should probably be nested within the
        clusters (clustervars) due to the within-panel correlation induced by
        the FEs.  (this is not the case for *all* the absvars, only those that
        are treated as growing as N grows)
     7. If you run analytic or probability weights, you are responsible for
        ensuring that the weights stay constant within each unit of a fixed
        effect (e.g. individual), or that it is correct to allow
        varying-weights for that case.
     8. Be aware that adding several HDFEs is not a panacea.  The first
        limitation is that it only uses within variation (more than acceptable
        if you have a large enough dataset).  The second and subtler
        limitation occurs if the fixed effects are themselves outcomes of the
        variable of interest (as crazy as it sounds).  For instance, imagine a
        regression where we study the effect of past corporate fraud on future
        firm performance.  We add firm, CEO and time fixed-effects (standard
        practice). This introduces a serious flaw: whenever a fraud event is
        discovered, i) future firm performance will suffer, and ii) a CEO
        turnover will likely occur.  Moreover, after fraud events, the new
        CEOs are usually specialized in dealing with the aftershocks of such
        events (and are usually accountants or lawyers).  The fixed effects of
        these CEOs will also tend to be quite low, as they tend to manage
        firms with very risky outcomes.  Therefore, the regressor (fraud)
        affects the fixed effect (identity of the incoming CEO).  Adding
        particularly low CEO fixed effects will then overstate the performance
        of the firm, and thus <i>understate</i> the negative effects of fraud on
        future firm performance.
<br><br>
<span class=result><u>Missing Features</u></span>
<br><br>
    (If you are interested in discussing these or others, feel free to contact
        me)
<br><br>
    Code, medium term:
<br><br>
    - Complete GT preconditioning (v4)
    - Improve algorithm that recovers the fixed effects (v5)
    - Improve statistics and tests related to the fixed effects (v5)
    - Implement a -bootstrap- option in DoF estimation (v5)
<br><br>
    Code, long term:
<br><br>
    - The interaction with cont vars (i.a#c.b) may suffer from numerical
      accuracy issues, as we are dividing by a sum of squares
    - Calculate exact DoF adjustment for 3+ HDFEs (note: not a problem with
      cluster VCE when one FE is nested within the cluster)
    - More postestimation commands (lincom? margins?)
<br><br>
    Theory:
<br><br>
    - Add a more thorough discussion on the possible identification issues
    - Find out a way to use reghdfe iteratively with CUE (right now only
      OLS/2SLS/GMM2S/LIML give the exact same results)
    - Not sure if I should add an F-test for the absvars in the vce(robust)
      and vce(cluster) cases.  Discussion on e.g. -areg- (methods and
      formulas) and textbooks suggests not; on the other hand, there may be
      alternatives:  <i>A Heteroskedasticity-Robust F-Test Statistic for</i>
      <i>Individual Effects</i>
<br><br>
<a name="examples"></a><span class=result><u>Examples</u></span>
<br><br>
--------------------------------------------------------------------------------
    Setup
        <span class=input>. sysuse auto</span>
<br><br>
    Simple case - one fixed effect
        <span class=input>. reghdfe price weight length, absorb(rep78)</span>
--------------------------------------------------------------------------------
<br><br>
    As above, but also compute clustered standard errors
        <span class=input>. reghdfe price weight length, absorb(rep78) vce(cluster rep78)</span>
--------------------------------------------------------------------------------
<br><br>
    Two and three sets of fixed effects
        <span class=input>. webuse nlswork</span>
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa south , absorb(idcode</span>
            <span class=result>year)</span>
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa south , absorb(idcode</span>
            <span class=result>year occ)</span>
--------------------------------------------------------------------------------
<br><br>
<span class=result><u>Advanced examples</u></span>
<br><br>
    Save the FEs as variables
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa south ,</span>
            <span class=result>absorb(FE1=idcode FE2=year)</span>
<br><br>
    Report nested F-tests
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa south , absorb(idcode</span>
            <span class=result>year) nested</span>
<br><br>
    Do AvgE instead of absorb() for one FE
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa south , absorb(idcode</span>
            <span class=result>year) avge(occ)</span>
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa south , absorb(idcode</span>
            <span class=result>year) avge(AvgByOCC=occ)</span>
<br><br>
    Check that FE coefs are close to 1.0
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa , absorb(idcode year)</span>
            <span class=result>check</span>
<br><br>
    Save first mobility group
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa , absorb(idcode occ)</span>
            <span class=result>group(mobility_occ)</span>
<br><br>
    Factor interactions in the independent variables
        <span class=input>. reghdfe ln_w i.grade#i.age ttl_exp tenure not_smsa , absorb(idcode</span>
            <span class=result>occ)</span>
<br><br>
    Interactions in the absorbed variables (notice that only the <i>#</i> symbol is
    allowed)
        <span class=input>. reghdfe ln_w grade age ttl_exp tenure not_smsa , absorb(idcode#occ)</span>
<br><br>
    Interactions in both the absorbed and AvgE variables (again, only the <i>#</i>
    symbol is allowed)
        <span class=input>. reghdfe ln_w grade age ttl_exp not_smsa , absorb(idcode#occ)</span>
            <span class=result>avge(tenure#occ)</span>
<br><br>
    IV regression
        <span class=input>. sysuse auto</span>
        <span class=input>. reghdfe price weight (length=head), absorb(rep78)</span>
        <span class=input>. reghdfe price weight (length=head), absorb(rep78) first</span>
        <span class=input>. reghdfe price weight (length=head), absorb(rep78) ivsuite(ivregress)</span>
<br><br>
    Factorial interactions
        <span class=input>. reghdfe price weight (length=head), absorb(rep78)</span>
        <span class=input>. reghdfe price weight length, absorb(rep78 turn##c.price)</span>
<br><br>
<br><br>
<a name="results"></a><span class=result><u>Stored results</u></span>
<br><br>
    <span class=result>reghdfe</span> stores the following in <span class=result>e()</span>:
<br><br>
    <i>Note: it also keeps most e() results placed by the regression subcommands</i>
    <i>(ivreg2, ivregress)</i>
<br><br>
    Scalars            
      <span class=result>e(N)</span>                    number of observations
      <span class=result>e(N_hdfe)</span>               number of absorbed fixed-effects
      <span class=result>e(tss)</span>                  total sum of squares
      <span class=result>e(rss)</span>                  residual sum of squares
      <span class=result>e(r2)</span>                   R-squared
      <span class=result>e(r2_a)</span>                 adjusted R-squared
      <span class=result>e(r2_within)</span>            Within R-squared
      <span class=result>e(r2_a_within)</span>          Adjusted Within R-squared
      <span class=result>e(df_a)</span>                 degrees of freedom lost due to the fixed effects
      <span class=result>e(rmse)</span>                 root mean squared error
      <span class=result>e(ll)</span>                   log-likelihood
      <span class=result>e(ll_0)</span>                 log-likelihood of fixed-effect-only regression
      <span class=result>e(F)</span>                    F statistic
      <span class=result>e(F_absorb)</span>             F statistic for absorbed effect <i>note: currently</i>
                                <i>disabled</i>
      <span class=result>e(rank)</span>                 rank of <span class=result>e(V)</span>
      <span class=result>e(N_clustervars)</span>        number of cluster variables
        
      <span class=result>e(clust</span>#<span class=result>)</span>               number of clusters for the #th cluster variable
      <span class=result>e(N_clust)</span>              number of clusters; minimum of <i>e(clust#)</i>
<br><br>
      <span class=result>e(K</span>#<span class=result>)</span>                   Number of categories of the #th absorbed FE
      <span class=result>e(M</span>#<span class=result>)</span>                   Number of redundant categories of the #th
                                absorbed FE
      <span class=result>e(mobility)</span>             Sum of all <span class=result>e(M#)</span>
      <span class=result>e(df_m)</span>                 model degrees of freedom
      <span class=result>e(df_r)</span>                 residual degrees of freedom
<br><br>
    Macros             
      <span class=result>e(cmd)</span>                  <span class=result>reghdfe</span>
      <span class=result>e(subcmd)</span>               either <span class=result>regress</span>, <span class=result>ivreg2</span> or <span class=result>ivregress</span>
      <span class=result>e(model)</span>                <span class=result>ols</span>, <span class=result>iv</span>, <span class=result>gmm2s</span>, <span class=result>liml</span> or <span class=result>cue</span>
      <span class=result>e(cmdline)</span>              command as typed
      <span class=result>e(dofmethod)</span>            dofmethod employed in the regression
      <span class=result>e(depvar)</span>               name of dependent variable
      <span class=result>e(indepvars)</span>            names of independent variables
      <span class=result>e(endogvars)</span>            names of endogenous right-hand-side variables
      <span class=result>e(instruments)</span>          names of excluded instruments
      <span class=result>e(absvars)</span>              name of the absorbed variables or interactions
      <span class=result>e(title)</span>                title in estimation output
      <span class=result>e(clustvar)</span>             name of cluster variable
      <span class=result>e(clustvar</span>#<span class=result>)</span>            name of the #th cluster variable
      <span class=result>e(vce)</span>                  <i>vcetype</i> specified in <span class=result>vce()</span>
      <span class=result>e(vcetype)</span>              title used to label Std. Err.
      <span class=result>e(stage)</span>                stage within an IV-regression; only if <i>stages()</i>
                                was used
      <span class=result>e(properties)</span>           <span class=result>b V</span>
<br><br>
    Matrices           
      <span class=result>e(b)</span>                    coefficient vector
      <span class=result>e(V)</span>                    variance-covariance matrix of the estimators
<br><br>
    Functions          
      <span class=result>e(sample)</span>               marks estimation sample
<br><br>
<a name="contact"></a><span class=result><u>Author</u></span>
<br><br>
    Sergio Correia
    Fuqua School of Business, Duke University
    Email: sergio.correia@duke.edu
<br><br>
<a name="user_guide"></a><span class=result><u>User Guide</u></span>
<br><br>
    A copy of this help file, as well as a more in-depth user guide is in
    development and will be available at http://scorreia.com/reghdfe.
<br><br>
<a name="updates"></a><span class=result><u>Latest Updates</u></span>
<br><br>
    <span class=result>reghdfe</span> is updated frequently, and upgrades or minor bug fixes may not be
    immediately available in SSC.  To check or contribute to the latest
    version of reghdfe, explore the Github repository.  Bugs or missing
    features can be discussed through email or at the Github issue tracker.
<br><br>
    To see your current version and installed dependencies, type <span class=result>reghdfe,</span>
    <span class=result>version</span>
<br><br>
<a name="acknowledgements"></a><span class=result><u>Acknowledgements</u></span>
<br><br>
    This package wouldn't have existed without the invaluable feedback and
    contributions of Paulo Guimaraes, Amine Ouazad, Mark Schaffer and Kit
    Baum. Also invaluable are the great bug-spotting abilities of many users.
<br><br>
    In addition, <i>reghdfe</i> is build upon important contributions from the Stata
    community:
<br><br>
    reg2hdfe, from Paulo Guimaraes, and a2reg from Amine Ouazad, were the
        inspiration and building blocks on which reghdfe was built.
 
    ivreg2, by Christopher F Baum, Mark E Schaffer and Steven Stillman, is the
        package used by default for instrumental-variable regression.
<br><br>
    avar by Christopher F Baum and Mark E Schaffer, is the package used for
        estimating the HAC-robust standard errors of ols regressions.
<br><br>
    tuples by Joseph Lunchman and Nicholas Cox, is used when computing
        standard errors with multi-way clustering (two or more clustering
        variables).
<br><br>
<a name="references"></a><span class=result><u>References</u></span>
<br><br>
The algorithm underlying reghdfe is a generalization of the works by:
<br><br>
    Paulo Guimaraes and Pedro Portugal. "A Simple Feasible Alternative
        Procedure to Estimate Models with High-Dimensional Fixed Effects".
        <i>Stata Journal, 10(4), 628-649, 2010.</i>  [link]
<br><br>
    Simen Gaure. "OLS with Multiple High Dimensional Category Dummies".
        <i>Memorandum 14/2010, Oslo University, Department of Economics, 2010.</i>
        [link]
<br><br>
It addresses many of the limitation of previous works, such as possible lack
of convergence, arbitrary slow convergence times, and being limited to only
two or three sets of fixed effects (for the first paper).  The paper
explaining the specifics of the algorithm is a work-in-progress and available
upon request.
<br><br>
If you use this program in your research, please cite either the REPEC entry or
the aforementioned papers.
<br><br>
<span class=result><u>Additional References</u></span>
<br><br>
For details on the Aitken acceleration technique employed, please see "method 3"
as described by:
<br><br>
    Macleod, Allan J. "Acceleration of vector sequences by multi-dimensional
        Delta-2 methods." <i>Communications in Applied Numerical Methods 2.4</i>
        <i>(1986): 385-392.</i>
<br><br>
For the rationale behind interacting fixed effects with continuous variables,
see:
<br><br>
    Duflo, Esther. "The medium run effects of educational expansion: Evidence
        from a large school construction program in Indonesia." <i>Journal of</i>
        <i>Development Economics 74.1 (2004): 163-197.</i> [link]
<br><br>
Also see:
<br><br>
    Abowd, J. M., R. H. Creecy, and F. Kramarz 2002.  Computing person and
        firm effects using linked longitudinal employer-employee data.  <i>Census</i>
        <i>Bureau Technical Paper TP-2002-06.</i>
<br><br>
    Cameron, A. Colin &amp; Gelbach, Jonah B. &amp; Miller, Douglas L., 2011.  "Robust
        Inference With Multiway Clustering," <i>Journal of Business &amp; Economic</i>
        <i>Statistics, American Statistical Association, vol. 29(2), pages</i>
        <i>238-249.</i>
<br><br>
    Gormley, T. &amp; Matsa, D. 2014.  "Common errors: How to (and not to) control
        for unobserved heterogeneity." <i>The Review of Financial Studies, vol.</i>
        <i>27(2), pages 617-661.</i>
<br><br>
    Mittag, N. 2012.  "New methods to estimate models with large sets of fixed
        effects with an application to matched employer-employee data from
        Germany." <i>FDZ-Methodenreport 02/2012</i><i>.</i>
</pre>
</body>
</html>
